import { NodeSSH } from 'node-ssh';
import { EventEmitter } from 'events';
import { PortManager } from './portManager';

export interface SSHConfig {
  host: string;
  username: string;
  password?: string;
  privateKey?: string;
  port?: number;
}

export interface InstallationResult {
  success: boolean;
  credentials?: {
    siteUrl: string;
    adminUrl: string;
    username: string;
    password: string;
  };
  siteInfo?: {
    domain: string;
    ipAddress: string;
    accessUrl: string;
    adminUrl: string;
  };
  dnsInstructions?: {
    cloudflare: string[];
    generic: string[];
  };
  error?: string;
}

export interface WordPressConfig {
  credentials?: {
    siteTitle: string;
    adminUsername: string;
    adminEmail: string;
    adminPassword: string;
  };
  theme?: {
    _id: string;
    slug: string;
    downloadUrl?: string;
  };
  plugins?: string[]; // Array of plugin slugs
}

export interface InstallationOptions {
  domain: string;
  userEmail: string;
  userId: string;
  wordpressConfig?: WordPressConfig | null;
  skipSystemSetup?: boolean; // Skip system setup if server is already configured
  installationId?: string; // Installation document ID for port assignment
}

export class SSHExecutor extends EventEmitter {
  private ssh: NodeSSH;
  private config: SSHConfig;
  private connected: boolean = false;
  private completedSteps: Set<string> = new Set();
  private currentStep: string = '';

  constructor(config: SSHConfig) {
    super();
    this.ssh = new NodeSSH();
    this.config = config;
  }

  async connect(): Promise<void> {
    try {
      this.emit('output', `üîå Attempting SSH connection to ${this.config.host}:${this.config.port || 22}`);
      this.emit('output', `üë§ Username: ${this.config.username}`);
      this.emit('output', `üîê Auth method: ${this.config.privateKey ? 'Private Key' : 'Password'}`);
      
      await this.ssh.connect(this.config);
      this.connected = true;
      this.emit('connected');
      this.emit('output', `‚úÖ SSH connection established successfully to ${this.config.host}`);
    } catch (error) {
      this.emit('output', `‚ùå SSH connection failed to ${this.config.host}:${this.config.port || 22}`);
      this.emit('output', `‚ùå Connection error: ${error.message}`);
      this.emit('output', `üîç Possible causes:`);
      this.emit('output', `   ‚Ä¢ Server is not accessible on port ${this.config.port || 22}`);
      this.emit('output', `   ‚Ä¢ Wrong username or credentials`);
      this.emit('output', `   ‚Ä¢ Firewall blocking connection`);
      this.emit('output', `   ‚Ä¢ SSH service not running on server`);
      this.emit('error', `SSH Connection Failed: ${error.message}`);
      throw new Error(`Failed to connect to ${this.config.host}: ${error.message}`);
    }
  }

  async disconnect(): Promise<void> {
    if (this.connected) {
      this.ssh.dispose();
      this.connected = false;
      this.emit('disconnected');
    }
  }

  private async execCommand(command: string): Promise<any> {
    try {
      // Log command being executed (for debugging)
      this.emit('output', `üîß Executing: ${command}`);
      
      const result = await this.ssh.execCommand(command);
      
      // Log command result details
      this.emit('output', `‚úÖ Command completed with exit code: ${result.code}`);
      if (result.stdout && result.stdout.trim()) {
        this.emit('output', `üì§ STDOUT: ${result.stdout.trim()}`);
      }
      if (result.stderr && result.stderr.trim()) {
        this.emit('output', `üì§ STDERR: ${result.stderr.trim()}`);
      }
      
      return result;
    } catch (error) {
      this.emit('output', `‚ùå Command execution failed: ${command}`);
      this.emit('output', `‚ùå Error details: ${error.message}`);
      this.emit('error', `Command: ${command}\nError: ${error.message}`);
      throw error;
    }
  }

  private async execCommandWithOutput(command: string): Promise<void> {
    const result = await this.execCommand(command);
    if (result.stdout) this.emit('output', result.stdout);
    if (result.stderr && result.code !== 0) {
      this.emit('output', `‚ö†Ô∏è Command stderr (code ${result.code}): ${result.stderr}`);
      this.emit('error', result.stderr);
    }
    if (result.code !== 0) {
      const errorMsg = `Command failed with code ${result.code}: ${result.stderr}`;
      this.emit('output', `‚ùå ${errorMsg}`);
      throw new Error(errorMsg);
    }
  }

  private async detectServerConfiguration(): Promise<{
    hasWordOps: boolean;
    hasNginx: boolean;
    hasMySQL: boolean;
    hasPHP: boolean;
    hasWPCLI: boolean;
    isConfigured: boolean;
  }> {
    const checks = {
      hasWordOps: false,
      hasNginx: false,
      hasMySQL: false,
      hasPHP: false,
      hasWPCLI: false,
      isConfigured: false,
    };

    try {
      // Check WordOps
      const woCheck = await this.execCommand('which wo 2>/dev/null || echo ""');
      checks.hasWordOps = !!woCheck.stdout.trim();

      // Check Nginx
      const nginxCheck = await this.execCommand('which nginx 2>/dev/null || echo ""');
      checks.hasNginx = !!nginxCheck.stdout.trim();

      // Check MySQL
      const mysqlCheck = await this.execCommand('which mysql 2>/dev/null || echo ""');
      checks.hasMySQL = !!mysqlCheck.stdout.trim();

      // Check PHP
      const phpCheck = await this.execCommand('which php 2>/dev/null || echo ""');
      checks.hasPHP = !!phpCheck.stdout.trim();

      // Check WP-CLI
      const wpCliCheck = await this.execCommand('which wp 2>/dev/null || echo ""');
      checks.hasWPCLI = !!wpCliCheck.stdout.trim();

      // Server is considered configured if it has the core components
      checks.isConfigured = checks.hasWordOps && checks.hasNginx && checks.hasMySQL && checks.hasPHP;

      this.emit('output', `üîç Detec√ß√£o de configura√ß√£o:`);
      this.emit('output', `   WordOps: ${checks.hasWordOps ? '‚úÖ' : '‚ùå'}`);
      this.emit('output', `   Nginx: ${checks.hasNginx ? '‚úÖ' : '‚ùå'}`);
      this.emit('output', `   MySQL: ${checks.hasMySQL ? '‚úÖ' : '‚ùå'}`);
      this.emit('output', `   PHP: ${checks.hasPHP ? '‚úÖ' : '‚ùå'}`);
      this.emit('output', `   WP-CLI: ${checks.hasWPCLI ? '‚úÖ' : '‚ùå'}`);
      this.emit('output', `   Servidor configurado: ${checks.isConfigured ? '‚úÖ' : '‚ùå'}`);

      return checks;
    } catch (error) {
      this.emit('output', `‚ö†Ô∏è  Erro na detec√ß√£o: ${error.message}`);
      return checks;
    }
  }

  async executeInstallation(options: InstallationOptions): Promise<InstallationResult> {
    // Set overall installation timeout (10 minutes)
    const installationTimeout = 10 * 60 * 1000; // 10 minutes
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error('Installation timeout: Process exceeded 10 minutes'));
      }, installationTimeout);
    });
    
    // Race between installation and timeout
    return Promise.race([
      this.executeInstallationInternal(options),
      timeoutPromise
    ]);
  }

  private async executeInstallationInternal(options: InstallationOptions): Promise<InstallationResult> {
    if (!this.connected) {
      await this.connect();
    }

    const { domain, userEmail, userId, wordpressConfig, installationId } = options;
    
    // Initialize site identifier (will be set based on installation type)
    let siteIdentifier = domain;
    
    // Use custom WordPress credentials if provided, otherwise defaults
    const wpUser = wordpressConfig?.credentials?.adminUsername || 'admin';
    const wpPass = wordpressConfig?.credentials?.adminPassword || 'admin123';
    const wpEmail = wordpressConfig?.credentials?.adminEmail || userEmail;
    
    // Escape password for bash to handle special characters safely
    const escapedWpPass = wpPass.replace(/'/g, "'\"'\"'").replace(/\$/g, '\\$');
    const siteTitle = wordpressConfig?.credentials?.siteTitle || 'WordPress Site';
    const ipAddress = this.config.host;
    
    // Check if this is an IP-based installation
    const isIPInstallation = /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/.test(domain);
    let assignedPort: number | undefined;
    let previewDomain: string | undefined;

    // Always assign a unique port for preview access (both domain and IP installations)
    if (installationId) {
      try {
        assignedPort = await PortManager.getNextAvailablePort();
        previewDomain = PortManager.generatePreviewDomain(userId, siteTitle);
        this.emit('output', `üî¢ Porto atribu√≠do: ${assignedPort}`);
        this.emit('output', `üåê Dom√≠nio de preview: ${previewDomain}`);
        
        // Reserve the port
        await PortManager.reservePort(installationId, assignedPort);
      } catch (portError) {
        this.emit('output', `‚ö†Ô∏è Erro ao atribuir porto: ${portError.message}`);
        // Continue with default port 80 if port assignment fails
      }
    }

    try {
      // Auto-detect server configuration
      const serverConfig = await this.detectServerConfiguration();
      const skipSystemSetup = options.skipSystemSetup || serverConfig.isConfigured;

      if (skipSystemSetup) {
        this.emit('output', 'üöÄ Servidor j√° configurado - executando instala√ß√£o r√°pida de site');
      } else {
        this.emit('output', '‚öôÔ∏è Servidor novo detectado - executando configura√ß√£o completa');
      }

      // Step 0: Pre-flight checks  
      await this.executeStep('preflight', 'üîç [0/6] Verifica√ß√µes Iniciais', async () => {
        this.emit('output', 'üîç Verificando configura√ß√£o do servidor...');
        
        // Check if WordOps is installed and if site already exists
        const woCheck = await this.execCommand('which wo');
        if (woCheck.stdout) {
          this.emit('output', '‚úÖ WordOps detectado, verificando sites existentes...');
          
          // Check if the domain already exists in WordOps
          const siteCheck = await this.execCommand(`wo site info ${domain} 2>/dev/null || echo "not found"`);
          if (siteCheck.stdout && !siteCheck.stdout.includes('not found')) {
            this.emit('output', '‚ö†Ô∏è  Site j√° existe no WordOps!');
            throw new Error(`O dom√≠nio ${domain} j√° est√° configurado neste servidor. Por favor, remova o site existente primeiro ou use um dom√≠nio diferente.`);
          }
        }
        
        // Check if nginx config exists for this domain
        this.emit('output', 'üîç Verificando configura√ß√£o do Nginx...');
        const nginxCheck = await this.execCommand(`ls /etc/nginx/sites-available/${domain} 2>/dev/null || echo "not found"`);
        if (nginxCheck.stdout && !nginxCheck.stdout.includes('not found')) {
          this.emit('output', '‚ö†Ô∏è  Configura√ß√£o Nginx existente detectada!');
          throw new Error(`Configura√ß√£o Nginx para ${domain} j√° existe. Isso indica que um site j√° est√° configurado.`);
        }
        
        // Check if web directory exists
        this.emit('output', 'üîç Verificando diret√≥rios do site...');
        const dirCheck = await this.execCommand(`ls -la /var/www/${domain} 2>/dev/null || echo "not found"`);
        if (dirCheck.stdout && !dirCheck.stdout.includes('not found')) {
          // Check if it has WordPress files
          const wpCheck = await this.execCommand(`ls /var/www/${domain}/htdocs/wp-config.php 2>/dev/null || echo "not found"`);
          if (wpCheck.stdout && !wpCheck.stdout.includes('not found')) {
            this.emit('output', '‚ö†Ô∏è  WordPress j√° instalado neste dom√≠nio!');
            throw new Error(`WordPress j√° est√° instalado em /var/www/${domain}. Por favor, remova a instala√ß√£o existente primeiro.`);
          }
        }
        
        // Check if MySQL database exists (if MySQL is installed)
        this.emit('output', 'üîç Verificando banco de dados...');
        const mysqlCheck = await this.execCommand('which mysql');
        if (mysqlCheck.stdout) {
          const dbName = domain.replace(/\./g, '_').replace(/-/g, '_');
          const dbCheck = await this.execCommand(`mysql -e "SHOW DATABASES LIKE '${dbName}'" 2>/dev/null || echo ""`);
          if (dbCheck.stdout && dbCheck.stdout.includes(dbName)) {
            this.emit('output', '‚ö†Ô∏è  Banco de dados j√° existe!');
            this.emit('output', `üí° Dica: O banco de dados ${dbName} j√° existe. Isso pode indicar uma instala√ß√£o anterior.`);
            // Don't throw error here, just warn - database might be from a failed attempt
          }
        }
        
        // Check available disk space
        this.emit('output', 'üîç Verificando espa√ßo em disco...');
        const diskCheck = await this.execCommand("df -h / | awk 'NR==2 {print $4}'");
        this.emit('output', `üíæ Espa√ßo dispon√≠vel: ${diskCheck.stdout.trim()}`);
        
        // Parse disk space to ensure we have at least 1GB free
        const diskSpace = diskCheck.stdout.trim();
        const spaceValue = parseFloat(diskSpace);
        const spaceUnit = diskSpace.replace(/[0-9.]/g, '').trim();
        if (spaceUnit === 'M' && spaceValue < 1000) {
          throw new Error('Espa√ßo em disco insuficiente. Pelo menos 1GB livre √© necess√°rio.');
        }
        
        this.emit('output', '‚úÖ [0/6] Verifica√ß√µes conclu√≠das, servidor pronto!');
      });

      // System setup steps (skip if server is already configured)
      if (!skipSystemSetup) {
        // Step 1: System Update
        await this.executeStep('system_update', 'üì¶ [1/6] Atualizando Sistema', async () => {
        this.emit('output', 'üîÑ Limpando processos travados...');
        // Kill any blocking apt/dpkg processes first
        await this.execCommandWithOutput('pkill -9 apt-get || true');
        await this.execCommandWithOutput('pkill -9 apt || true');
        await this.execCommandWithOutput('pkill -9 dpkg || true');
        
        this.emit('output', 'üîì Removendo locks...');
        // Remove lock files
        await this.execCommandWithOutput('rm -f /var/lib/dpkg/lock-frontend || true');
        await this.execCommandWithOutput('rm -f /var/lib/dpkg/lock || true');
        await this.execCommandWithOutput('rm -f /var/cache/apt/archives/lock || true');
        await this.execCommandWithOutput('rm -f /var/lib/apt/lists/lock || true');
        
        this.emit('output', '‚öôÔ∏è Configurando pacotes pendentes...');
        // Configure any pending packages
        await this.execCommandWithOutput('dpkg --configure -a || true');
        
        // Wait for cleanup
        await this.execCommandWithOutput('sleep 2');
        
        this.emit('output', 'üìã Atualizando lista de pacotes...');
        await this.execCommandWithOutput('apt-get update');
        
        this.emit('output', '‚¨ÜÔ∏è Atualizando sistema (pode demorar 2-3 minutos)...');
        await this.execCommandWithOutput('DEBIAN_FRONTEND=noninteractive apt-get upgrade -y --with-new-pkgs');
        
        this.emit('output', '‚úÖ [1/6] Sistema atualizado!');
      });

      // Step 2: Install Dependencies
      await this.executeStep('dependencies', 'üîß [2/6] Instalando Depend√™ncias', async () => {
        this.emit('output', 'üì• Instalando ferramentas b√°sicas...');
        await this.execCommandWithOutput('DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget git software-properties-common');
        this.emit('output', '‚úÖ [2/6] Depend√™ncias instaladas!');
      });

      // Step 3: Install WordOps
      await this.executeStep('wordops', '‚ö° [3/6] Instalando WordOps', async () => {
        // Define MySQL root password for both branches
        const mysqlRootPass = 'TatameRoot2024!';
        
        const woCheck = await this.execCommand('which wo');
        if (!woCheck.stdout) {
          this.emit('output', 'üì¶ Baixando WordOps...');
          
          // Configure Git first (required by WordOps)
          await this.execCommandWithOutput(`git config --global user.name "Tatame Installer"`);
          await this.execCommandWithOutput(`git config --global user.email "${userEmail}"`);
          
          // Create WordOps config directory
          await this.execCommandWithOutput('mkdir -p /etc/wo');
          
          // Create WordOps config file to avoid interactive prompts
          const woConfig = `[user]
name = Tatame Installer
email = ${userEmail}

[mysql]
host = localhost
port = 3306
user = root
password = ${mysqlRootPass}
grant-host = localhost
db-name = wordpress
db-user = wordpress
db-password = wordpress

[wordpress]
user = admin
password = admin123
email = ${userEmail}
prefix = wp_
webroot = htdocs`;
          
          await this.execCommandWithOutput(`echo '${woConfig}' > /etc/wo/wo.conf`);
          
          // Install WordOps with environment variables and timeout
          this.emit('output', 'üì• Baixando instalador do WordOps...');
          await this.execCommandWithOutput('wget -qO wo wops.cc');
          
          this.emit('output', 'üöÄ Instalando WordOps (m√°ximo 4 minutos)...');
          // Use timeout to prevent hanging and force non-interactive mode
          await this.execCommandWithOutput(`timeout 240 bash -c 'export DEBIAN_FRONTEND=noninteractive && WO_INSTALL_USER="Tatame Installer" WO_INSTALL_EMAIL="${userEmail}" bash wo --force'`);
          
          await this.execCommandWithOutput('rm -f wo');
          this.emit('output', '‚úÖ [3/6] WordOps instalado com sucesso!');
          
          // Setup MySQL root access
          this.emit('output', 'üîß Configurando MySQL...');
          
          // Use sudo mysql to configure root access (works with auth_socket plugin)
          // mysqlRootPass is already defined above
          await this.execCommandWithOutput(`sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '${mysqlRootPass}';" || true`);
          await this.execCommandWithOutput(`sudo mysql -e "FLUSH PRIVILEGES;" || true`);
          
          // Create .my.cnf for root access with password
          const myCnf = `[client]
user=root
password=${mysqlRootPass}`;
          
          // Create in both locations to ensure WordOps finds it
          await this.execCommandWithOutput(`echo '${myCnf}' > /root/.my.cnf`);
          await this.execCommandWithOutput('chmod 600 /root/.my.cnf');
          await this.execCommandWithOutput(`echo '${myCnf}' > ~/.my.cnf`);
          await this.execCommandWithOutput('chmod 600 ~/.my.cnf');
          
          // Test connection with password
          await this.execCommandWithOutput(`mysql -u root -p'${mysqlRootPass}' -e "SELECT 1;" || true`);
        } else {
          this.emit('output', '‚úÖ [3/6] WordOps j√° instalado');
          
          // Still configure Git if not already done
          await this.execCommandWithOutput(`git config --global user.name "Tatame Installer" || true`);
          await this.execCommandWithOutput(`git config --global user.email "${userEmail}" || true`);
          
          // Ensure MySQL access is configured (same process as above)
          this.emit('output', 'üîß Reconfigurando MySQL...');
          // mysqlRootPass is already defined above
          await this.execCommandWithOutput(`sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '${mysqlRootPass}';" || true`);
          await this.execCommandWithOutput(`sudo mysql -e "FLUSH PRIVILEGES;" || true`);
          const myCnf = `[client]
user=root
password=${mysqlRootPass}`;
          await this.execCommandWithOutput(`echo '${myCnf}' > /root/.my.cnf || true`);
          await this.execCommandWithOutput('chmod 600 /root/.my.cnf || true');
          await this.execCommandWithOutput(`echo '${myCnf}' > ~/.my.cnf || true`);
          await this.execCommandWithOutput('chmod 600 ~/.my.cnf || true');
          await this.execCommandWithOutput(`mysql -u root -p'${mysqlRootPass}' -e "SELECT 1;" || true`);
        }
      });
      } else {
        this.emit('output', '‚ö° Servidor j√° configurado - pulando configura√ß√£o do sistema');
        this.emit('output', '‚úÖ WordOps, Nginx, MySQL e PHP j√° est√£o instalados');
        
        // If WP-CLI is not installed on existing server, install it quickly
        if (!serverConfig.hasWPCLI) {
          this.emit('output', 'üì¶ Instalando WP-CLI...');
          await this.execCommandWithOutput('curl -O https://raw.githubusercontent.com/wp-cli/wp-cli/v2.8.1/utils/wp-completion.bash');
          await this.execCommandWithOutput('wget https://raw.githubusercontent.com/wp-cli/wp-cli/v2.8.1/utils/wp-cli.phar');
          await this.execCommandWithOutput('chmod +x wp-cli.phar');
          await this.execCommandWithOutput('mv wp-cli.phar /usr/local/bin/wp');
          this.emit('output', '‚úÖ WP-CLI instalado');
        }
      }

      // Step 4: Create WordPress Site  
      await this.executeStep('wordpress', 'üåê [4/6] Criando Site WordPress', async () => {
        this.emit('output', `üåê Preparando para criar site: ${domain}`);
        
        // Double-check if site already exists (in case it was created between checks)
        this.emit('output', 'üîç Verificando site existente...');
        const siteCheck = await this.execCommand(`wo site info ${domain} 2>/dev/null || echo "not found"`);
        
        if (siteCheck.stdout && !siteCheck.stdout.includes('not found')) {
          this.emit('output', '‚ö†Ô∏è  Site detectado durante instala√ß√£o!');
          
          // Get detailed info about the existing site
          const siteDetails = await this.execCommand(`wo site info ${domain} --json 2>/dev/null || echo "{}"`);
          this.emit('output', 'üìã Informa√ß√µes do site existente encontrado.');
          
          // Ask user to handle it manually
          throw new Error(`ATEN√á√ÉO: Um site com o dom√≠nio ${domain} foi detectado durante a instala√ß√£o. Isso pode ter ocorrido por:\n` +
            `1. Outro usu√°rio criou o site simultaneamente\n` +
            `2. Uma instala√ß√£o anterior n√£o foi completamente removida\n` +
            `3. O site foi criado manualmente\n\n` +
            `Para continuar, voc√™ precisa primeiro remover o site existente usando: wo site delete ${domain} --force`);
        }
        
        // Wait for cleanup
        await this.execCommandWithOutput('sleep 2');
        
        // Create site with WordOps - with port support for IP installations
        let createCommand;
        
        if (assignedPort) {
          // For installations with assigned ports, create a unique site identifier
          siteIdentifier = `${domain}-port${assignedPort}`;
          this.emit('output', `üîß Criando site com porto customizado: ${assignedPort}`);
          
          // Create basic WordPress site first
          createCommand = `wo site create ${siteIdentifier} --wp --php82 --user='${wpUser}' --pass='${escapedWpPass}' --email='${wpEmail}'`;
        } else {
          // Standard domain-based installation (fallback)
          createCommand = `wo site create ${domain} --wp --php82 --user='${wpUser}' --pass='${escapedWpPass}' --email='${wpEmail}'`;
        }
        
        // Pre-flight checks before WordOps
        this.emit('output', 'üîç Executando verifica√ß√µes pr√©-voo...');
        
        // Check MySQL connectivity
        try {
          this.emit('output', 'üìä Testando conectividade MySQL...');
          const mysqlTest = await this.execCommand('timeout 10 mysql -e "SELECT 1" 2>&1');
          if (mysqlTest.code !== 0) {
            throw new Error(`MySQL n√£o acess√≠vel: ${mysqlTest.stderr}`);
          }
          this.emit('output', '‚úÖ MySQL conect√°vel');
        } catch (error) {
          throw new Error(`Falha na conectividade MySQL: ${error.message}`);
        }
        
        // Check WordOps health
        try {
          this.emit('output', 'üõ†Ô∏è  Testando WordOps...');
          const woTest = await this.execCommand('timeout 10 wo --version 2>&1');
          if (woTest.code !== 0) {
            throw new Error(`WordOps n√£o responsivo: ${woTest.stderr}`);
          }
          this.emit('output', '‚úÖ WordOps responsivo');
        } catch (error) {
          throw new Error(`Falha no teste WordOps: ${error.message}`);
        }
        
        // Check for hanging WordOps processes
        try {
          this.emit('output', 'üîç Verificando processos WordOps...');
          const woProcesses = await this.execCommand('pgrep -f "wo site create" | wc -l');
          const processCount = parseInt(woProcesses.stdout.trim());
          if (processCount > 0) {
            this.emit('output', `‚ö†Ô∏è  Detectados ${processCount} processos WordOps em execu√ß√£o`);
            this.emit('output', 'üßπ Limpando processos antigos...');
            await this.execCommand('pkill -f "wo site create" 2>/dev/null || true');
            await this.execCommand('sleep 3'); // Wait for cleanup
          }
          this.emit('output', '‚úÖ Processos WordOps limpos');
        } catch (error) {
          this.emit('output', `‚ö†Ô∏è  Aviso: N√£o foi poss√≠vel verificar processos: ${error.message}`);
        }
        
        // Check disk space
        try {
          this.emit('output', 'üíæ Verificando espa√ßo em disco...');
          const diskTest = await this.execCommand("df /var/www/ | awk 'NR==2 {print $4}'");
          const freeSpaceKB = parseInt(diskTest.stdout.trim());
          if (freeSpaceKB < 1048576) { // Less than 1GB
            throw new Error(`Espa√ßo insuficiente: ${Math.round(freeSpaceKB/1024)}MB dispon√≠vel, m√≠nimo 1GB`);
          }
          this.emit('output', `‚úÖ Espa√ßo suficiente: ${Math.round(freeSpaceKB/1024/1024)}GB`);
        } catch (error) {
          throw new Error(`Falha na verifica√ß√£o de espa√ßo: ${error.message}`);
        }
        
        this.emit('output', 'üîÑ Criando site com WordOps (m√°ximo 2 minutos)...');
        this.emit('output', `üéØ Comando: ${createCommand}`);
        
        // Try to create the site with improved timeout
        try {
          const createResult = await this.execCommand(`timeout 120 ${createCommand} 2>&1`);
          
          // Check if WordPress was created (even if SSL failed)
          const output = createResult.stdout + createResult.stderr;
          if (output.includes('Successfully created site') || 
              output.includes('Installing WordPress') ||
              output.includes('Aborting SSL certificate')) {
            this.emit('output', `‚úÖ [4/5] Site WordPress criado: ${domain}`);
            if (output.includes('Aborting SSL certificate')) {
              this.emit('output', '‚ö†Ô∏è  SSL certificate failed but site is accessible via HTTP');
            }
          } else if (createResult.code === 124 || createResult.code === 4) {
            this.emit('output', '‚ö†Ô∏è  WordPress creation timed out, checking if site was created...');
            // Check if site was partially created
            const checkSite = await this.execCommand(`wo site info ${domain} 2>/dev/null || echo "not found"`);
            if (checkSite.stdout && !checkSite.stdout.includes('not found')) {
              this.emit('output', '‚úÖ [4/5] Site was created despite timeout');
            } else {
              throw new Error('Site creation timed out and site not found');
            }
          } else {
            throw new Error('Failed to create WordPress site');
          }
        } catch (error) {
          this.emit('output', `‚ùå Erro na cria√ß√£o do site: ${error.message}`);
          
          // Enhanced error diagnostics
          this.emit('output', 'üîç Executando diagn√≥sticos...');
          
          // Check if timeout
          if (error.code === 124 || error.code === 4 || error.message.includes('timeout')) {
            this.emit('output', '‚è∞ Timeout detectado - verificando se site foi criado...');
            
            // Check if site exists anyway
            const checkSite = await this.execCommand(`wo site info ${domain} 2>/dev/null || echo "not found"`);
            if (checkSite.stdout && !checkSite.stdout.includes('not found')) {
              this.emit('output', '‚úÖ [4/5] Site foi criado apesar do timeout, continuando...');
            } else {
              // Detailed timeout analysis
              this.emit('output', 'üìä An√°lise do timeout:');
              
              // Check MySQL status
              const mysqlStatus = await this.execCommand('systemctl is-active mysql 2>/dev/null || echo "unknown"');
              this.emit('output', `   ‚Ä¢ MySQL status: ${mysqlStatus.stdout.trim()}`);
              
              // Check disk usage
              const diskUsage = await this.execCommand("df -h /var/www/ | awk 'NR==2 {print $5}'");
              this.emit('output', `   ‚Ä¢ Disk usage: ${diskUsage.stdout.trim()}`);
              
              // Check memory
              const memUsage = await this.execCommand("free | awk 'NR==2{printf \"%.1f%%\", $3*100/$2 }'");
              this.emit('output', `   ‚Ä¢ Memory usage: ${memUsage.stdout.trim()}`);
              
              // Check load average
              const loadAvg = await this.execCommand("uptime | awk -F'load average:' '{print $2}'");
              this.emit('output', `   ‚Ä¢ Load average:${loadAvg.stdout.trim()}`);
              
              throw new Error(`WordOps timeout: Comando n√£o completou em 2 minutos. Causas poss√≠veis:
‚Ä¢ Download lento do WordPress
‚Ä¢ Problemas de conectividade MySQL
‚Ä¢ Alto uso de recursos do servidor
‚Ä¢ Problemas de DNS/rede
‚Ä¢ WordOps aguardando entrada do usu√°rio

Detalhes: ${error.message}`);
            }
          } else {
            // Non-timeout error - provide specific guidance
            this.emit('output', 'üí° Analisando erro espec√≠fico...');
            
            if (error.message.includes('mysql') || error.message.includes('database')) {
              throw new Error(`Erro MySQL: ${error.message}. Verifique se o MySQL est√° funcionando e acess√≠vel.`);
            } else if (error.message.includes('download') || error.message.includes('fetch')) {
              throw new Error(`Erro de download: ${error.message}. Verifique conectividade com a internet.`);
            } else if (error.message.includes('permission') || error.message.includes('denied')) {
              throw new Error(`Erro de permiss√£o: ${error.message}. Verifique permiss√µes do usu√°rio root.`);
            } else {
              throw new Error(`Falha na cria√ß√£o do site: ${error.message}`);
            }
          }
        }
        
        // Configure custom port access for installations with assigned ports
        if (assignedPort) {
          this.emit('output', `üîß Configurando acesso via porto ${assignedPort}...`);
          
          // Create custom Nginx configuration for the port
          const customConfigFile = `/etc/nginx/sites-available/${domain}-port${assignedPort}`;
          const wpPath = `/var/www/${siteIdentifier}/htdocs`;
          
          const nginxConfig = `
server {
    listen ${assignedPort};
    server_name ${ipAddress} _;
    
    root ${wpPath};
    index index.php index.html index.htm;
    
    # WordPress specific configuration
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    
    location ~ \\.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
    
    location ~ /\\.ht {
        deny all;
    }
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    
    # WordPress uploads
    location ~* \\.(jpg|jpeg|png|gif|css|js|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}`;
          
          // Write the custom configuration
          await this.execCommandWithOutput(`cat > ${customConfigFile} << 'EOF'${nginxConfig}
EOF`);
          
          // Enable the site
          await this.execCommandWithOutput(`ln -sf ${customConfigFile} /etc/nginx/sites-enabled/`);
          
        } else {
          // Standard IP configuration for domain-based installations
          this.emit('output', 'üîß Configurando acesso via IP...');
          
          const configFile = `/etc/nginx/sites-available/${domain}`;
          const configCheck = await this.execCommand(`ls ${configFile} 2>/dev/null || echo "not found"`);
          
          if (configCheck.stdout && !configCheck.stdout.includes('not found')) {
            // Add IP address to server_name directive
            await this.execCommandWithOutput(
              `sed -i "s/server_name ${domain};/server_name ${domain} ${ipAddress};/" ${configFile} || sed -i "s/server_name ${domain} www.${domain};/server_name ${domain} www.${domain} ${ipAddress};/" ${configFile}`
            );
          }
        }
        
        // Test and reload nginx configuration
        this.emit('output', 'üîÑ Testando configura√ß√£o do Nginx...');
        const nginxTest = await this.execCommand('nginx -t 2>&1');
        if (nginxTest.stdout.includes('syntax is ok') || nginxTest.stdout.includes('test is successful')) {
          // Reload nginx to apply changes
          await this.execCommandWithOutput('systemctl reload nginx');
          this.emit('output', `‚úÖ Site acess√≠vel via IP: http://${ipAddress}`);
        } else {
          this.emit('output', '‚ö†Ô∏è  N√£o foi poss√≠vel configurar acesso via IP, mas site funciona via dom√≠nio');
        }
      });

      // Step 5: Theme & Plugin Installation
      await this.executeStep('wordpress_customization', 'üé® [5/6] Configurando Tema & Plugins', async () => {
        this.emit('output', 'üé® Configurando WordPress com tema e plugins selecionados...');
        
        // Change to WordPress directory for WP-CLI commands
        const wpPath = `/var/www/${siteIdentifier}/htdocs`;
        
        // Configure WordPress URLs for port-based installations
        if (assignedPort) {
          const siteUrl = `http://${ipAddress}:${assignedPort}`;
          this.emit('output', `üîó Configurando URLs do WordPress para: ${siteUrl}`);
          
          await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp option update siteurl "${siteUrl}"`);
          await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp option update home "${siteUrl}"`);
        }
        
        // Update WordPress site title if provided
        if (siteTitle !== 'WordPress Site') {
          this.emit('output', `üìù Atualizando t√≠tulo do site para: ${siteTitle}`);
          await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp option update blogname "${siteTitle}"`);
        }
        
        // Install and activate theme if selected
        if (wordpressConfig?.theme?.slug) {
          const themeSlug = wordpressConfig.theme.slug;
          this.emit('output', `üé® Instalando tema: ${themeSlug}`);
          
          try {
            // Try to install from WordPress.org repository first
            await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp theme install ${themeSlug} --activate`);
            this.emit('output', `‚úÖ Tema ${themeSlug} instalado e ativado`);
          } catch (error) {
            // If installation fails, try downloading from URL if available
            if (wordpressConfig.theme.downloadUrl) {
              this.emit('output', `üì• Baixando tema de URL personalizada...`);
              await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp theme install ${wordpressConfig.theme.downloadUrl} --activate`);
              this.emit('output', `‚úÖ Tema personalizado instalado e ativado`);
            } else {
              this.emit('output', `‚ö†Ô∏è  Falha ao instalar tema ${themeSlug}, usando tema padr√£o`);
            }
          }
        }
        
        // Install plugins if selected
        if (wordpressConfig?.plugins?.length > 0) {
          this.emit('output', `üîå Instalando ${wordpressConfig.plugins.length} plugin(s)...`);
          
          for (const pluginSlug of wordpressConfig.plugins) {
            try {
              this.emit('output', `üì¶ Instalando plugin: ${pluginSlug}`);
              await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp plugin install ${pluginSlug} --activate`);
              this.emit('output', `‚úÖ Plugin ${pluginSlug} instalado e ativado`);
            } catch (error) {
              this.emit('output', `‚ö†Ô∏è  Falha ao instalar plugin ${pluginSlug}, continuando...`);
            }
          }
        }
        
        // Clear any caches
        this.emit('output', 'üßπ Limpando cache do WordPress...');
        await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp cache flush || true`);
        
        // Update permalinks to ensure everything works properly
        this.emit('output', 'üîó Configurando permalinks...');
        await this.execCommandWithOutput(`cd ${wpPath} && sudo -u www-data wp rewrite structure '/%postname%/' --hard || true`);
        
        this.emit('output', '‚úÖ [5/6] Tema e plugins configurados com sucesso!');
      });

      // Step 6: Security & Final Setup
      await this.executeStep('security', 'üîí [6/6] Finalizando Instala√ß√£o', async () => {
        // Set proper permissions
        await this.execCommandWithOutput(`chown -R www-data:www-data /var/www/${domain}/htdocs || true`);
        await this.execCommandWithOutput(`find /var/www/${domain}/htdocs -type d -exec chmod 755 {} \\; || true`);
        await this.execCommandWithOutput(`find /var/www/${domain}/htdocs -type f -exec chmod 644 {} \\; || true`);
        
        // Configure firewall
        await this.execCommandWithOutput('ufw allow 22/tcp || true');
        await this.execCommandWithOutput('ufw allow 80/tcp || true');
        await this.execCommandWithOutput('ufw allow 443/tcp || true');
        
        // Enable UFW with multiple fallback methods
        this.emit('output', 'üîß Habilitando firewall UFW...');
        try {
          // Try non-interactive force enable first
          const ufwResult = await this.execCommand('timeout 15 ufw --force enable 2>&1 || echo "ufw_failed"');
          if (ufwResult.stdout.includes('ufw_failed') || ufwResult.code !== 0) {
            this.emit('output', '‚ö†Ô∏è  UFW force enable failed, trying alternative...');
            // Fallback: try with echo method
            await this.execCommand('timeout 10 bash -c "echo y | ufw enable" 2>&1 || true');
          }
          this.emit('output', '‚úÖ Firewall UFW configurado');
        } catch (error) {
          this.emit('output', '‚ö†Ô∏è  Firewall skip - continuando instala√ß√£o');
        }
        
        // Ensure step completion is logged
        this.emit('output', 'üîí Permiss√µes e seguran√ßa configuradas');
        this.emit('output', 'üéØ Finalizando √∫ltima etapa...');
        
        this.emit('output', '‚úÖ [6/6] Instala√ß√£o finalizada!');
      });

      // Emit explicit installation completion event
      this.emit('output', '\nüéâ TODAS AS ETAPAS CONCLU√çDAS!');
      this.emit('installationComplete', { success: true, message: 'Installation steps completed' });

      // Generate success response with instructions
      this.emit('output', '\n=================================');
      if (skipSystemSetup) {
        this.emit('output', '‚úÖ NOVO SITE WORDPRESS ADICIONADO!');
        this.emit('output', 'üöÄ Instala√ß√£o r√°pida conclu√≠da com sucesso');
      } else {
        this.emit('output', '‚úÖ WORDPRESS INSTALADO COM SUCESSO!');
        this.emit('output', 'üÜï Servidor configurado do zero');
      }
      this.emit('output', '=================================\n');
      
      // Generate access URLs and methods
      const accessMethods: Array<{type: 'ip' | 'port' | 'preview' | 'domain', url: string, primary?: boolean}> = [];
      let primaryAccessUrl: string;
      let primaryAdminUrl: string;

      if (assignedPort) {
        // Port-based access for installations with assigned ports
        primaryAccessUrl = `http://${ipAddress}:${assignedPort}`;
        primaryAdminUrl = `http://${ipAddress}:${assignedPort}/wp-admin`;
        
        accessMethods.push({
          type: 'port',
          url: primaryAccessUrl,
          primary: true
        });
        
        // Add preview domain if available
        if (previewDomain) {
          accessMethods.push({
            type: 'preview',
            url: `http://${previewDomain}`,
            primary: false
          });
        }
        
        // Add domain access as secondary for domain-based installations
        if (!isIPInstallation) {
          accessMethods.push({
            type: 'domain',
            url: `http://${domain}`,
            primary: false
          });
        }
        
        // Add IP without port as secondary (will show default site)
        accessMethods.push({
          type: 'ip',
          url: `http://${ipAddress}`,
          primary: false
        });
        
      } else {
        // Fallback access method when no port assigned
        if (isIPInstallation) {
          primaryAccessUrl = `http://${ipAddress}`;
          primaryAdminUrl = `http://${ipAddress}/wp-admin`;
        } else {
          primaryAccessUrl = `http://${domain}`;
          primaryAdminUrl = `http://${domain}/wp-admin`;
        }
        
        accessMethods.push({
          type: isIPInstallation ? 'ip' : 'domain',
          url: primaryAccessUrl,
          primary: true
        });
        
        // Add alternate access methods
        if (!isIPInstallation && domain !== ipAddress) {
          accessMethods.push({
            type: 'ip',
            url: `http://${ipAddress}`,
            primary: false
          });
        }
      }

      const accessUrl = primaryAccessUrl;
      const adminUrl = primaryAdminUrl;
      
      // Generate DNS instructions
      const dnsInstructions = {
        cloudflare: [
          '1. Fa√ßa login no Cloudflare (cloudflare.com)',
          '2. Selecione seu dom√≠nio',
          '3. V√° para configura√ß√µes de DNS',
          `4. Adicione registro A: @ ‚Üí ${ipAddress}`,
          `5. Adicione registro A: www ‚Üí ${ipAddress}`,
          '6. Desative o proxy (nuvem laranja) inicialmente',
          '7. Aguarde 5-10 minutos para propaga√ß√£o'
        ],
        generic: [
          'No seu provedor de DNS, adicione:',
          `Tipo: A | Nome: @ | Valor: ${ipAddress}`,
          `Tipo: A | Nome: www | Valor: ${ipAddress}`
        ]
      };
      
      // Display instructions
      this.emit('output', 'üìù CREDENCIAIS DE ACESSO:');
      this.emit('output', '------------------------');
      this.emit('output', `Usu√°rio: ${wpUser}`);
      this.emit('output', `Senha: ${wpPass}`);
      this.emit('output', '');
      this.emit('output', 'üåê ACESSO AO SITE:');
      this.emit('output', '------------------------');
      this.emit('output', `Site: ${accessUrl}`);
      this.emit('output', `Admin: ${adminUrl}`);
      this.emit('output', '');
      this.emit('output', 'üîß CONFIGURA√á√ÉO DNS (Cloudflare):');
      this.emit('output', '------------------------');
      dnsInstructions.cloudflare.forEach(instruction => {
        this.emit('output', instruction);
      });
      
      // Return structured response
      return {
        success: true,
        siteInfo: {
          domain,
          ipAddress,
          accessUrl,
          adminUrl,
          assignedPort
        },
        credentials: {
          siteUrl: accessUrl,
          adminUrl: adminUrl,
          username: wpUser,
          password: wpPass
        },
        accessMethods,
        dnsInstructions
      };

    } catch (error) {
      this.emit('error', `Installation failed: ${error.message}`);
      throw error;
    } finally {
      await this.disconnect();
    }
  }

  private async executeStep(stepId: string, stepName: string, stepFunction: () => Promise<void>): Promise<void> {
    this.currentStep = stepId;
    this.emit('stepStart', { id: stepId, name: stepName });
    this.emit('output', `\nüöÄ Starting step: ${stepName}`);
    this.emit('output', `üìã Step ID: ${stepId}`);
    this.emit('output', '=' .repeat(60));
    
    const stepStartTime = Date.now();
    
    try {
      await stepFunction();
      const stepDuration = Date.now() - stepStartTime;
      this.completedSteps.add(stepId);
      this.emit('output', `‚úÖ Step completed: ${stepName} (${stepDuration}ms)`);
      this.emit('stepComplete', { id: stepId, name: stepName });
    } catch (error) {
      const stepDuration = Date.now() - stepStartTime;
      this.emit('output', `‚ùå Step failed: ${stepName} (${stepDuration}ms)`);
      this.emit('output', `üí• Error in step: ${stepId}`);
      this.emit('output', `üîç Error message: ${error.message}`);
      this.emit('output', `üìä Error stack: ${error.stack || 'No stack trace available'}`);
      
      // Add context about what we were trying to do
      this.emit('output', `üéØ Step context:`);
      this.emit('output', `   ‚Ä¢ Step: ${stepName}`);
      this.emit('output', `   ‚Ä¢ Stage: ${stepId}`);
      this.emit('output', `   ‚Ä¢ Current step: ${this.currentStep}`);
      this.emit('output', `   ‚Ä¢ Completed steps: [${Array.from(this.completedSteps).join(', ')}]`);
      
      this.emit('stepError', { 
        id: stepId, 
        name: stepName, 
        error: error.message,
        stack: error.stack,
        duration: stepDuration
      });
      
      throw new Error(`Step ${stepId} (${stepName}) failed: ${error.message}`);
    }
  }

  isConnected(): boolean {
    return this.connected;
  }

  getCurrentStep(): string {
    return this.currentStep;
  }

  getCompletedSteps(): string[] {
    return Array.from(this.completedSteps);
  }
}